---
type: breadcrumb
title: "Think: Plugin Settings Design for Memory Plugin"
topic: Plugin Settings Design for Memory Plugin
status: concluded
created: "2026-01-17T11:09:40.904Z"
updated: "2026-01-17T11:16:54.556Z"
tags:
  - think
  - concluded
scope: project
conclusion: |-
  Decision: Implement plugin settings via .claude/memory.local.md with tiered configuration.

  FILE FORMAT:
  - YAML frontmatter + markdown body (per Claude Code pattern)
  - File: .claude/memory.local.md
  - Add to .gitignore template

  TIER 1 SETTINGS (Exposed):
  - enabled: boolean (default: true) - master switch
  - ollama_host: string (default: http://localhost:11434)
  - chat_model: string (default: gemma3:4b)
  - embedding_model: string (default: embeddinggemma:latest)
  - context_window: number (default: 16384)

  TIER 2 SETTINGS (Advanced, documented):
  - health_threshold: number (default: 0.7) - graph health warning
  - semantic_threshold: number (default: 0.45) - similarity cutoff
  - auto_sync: boolean (default: false) - sync on startup

  IMPLEMENTATION:
  1. Create settings-parser.ts utility to parse YAML frontmatter
  2. Update hooks to read settings with fallback chain
  3. Create memory.example.md template
  4. Document in plugin README

  ERROR HANDLING:
  - Missing file → use plugin defaults (zero-config happy path)
  - Parse error → log warning, use defaults
  - Invalid value → log warning, use default for that setting
  - Ollama unavailable → graceful degradation (already handled)
promotedTo: decision-plugin-settings-design-for-memory-plugin
---

# Plugin Settings Design for Memory Plugin

_Thinking document created 2026-01-17T11:09:40.904Z_

## Thoughts

### 2026-01-17T11:10:09.535Z - Thought
Initial Assessment: The memory plugin has multiple hooks that could benefit from configurable settings:
1. SessionStart hook (start-memory-index.ts) - health threshold, auto-sync, semantic search
2. UserPromptSubmit hooks (memory-context.ts) - Ollama settings, relevance thresholds
3. PreCompact hook (memory-capture.ts) - capture behaviour
4. Core services (ollama.ts) - host URL, model selection, context limits

Key settings to consider:
- enabled: boolean - master enable/disable
- ollama_host: string - Ollama API endpoint (default: http://localhost:11434)
- embedding_model: string - model for semantic search (default: nomic-embed-text)
- chat_model: string - model for summaries (default: llama3.2)
- health_threshold: number - warning threshold for graph health (default: 70)
- auto_sync_on_startup: boolean - run memory sync on session start
- max_semantic_results: number - limit for semantic search results
- gotcha_injection_enabled: boolean - inject gotchas into context

### 2026-01-17T11:11:30.676Z - Thought (model:haiku style:Architect [f9501d52-89ce-40e4-a659-5a99dd7a851d])
Now I have the architectural context. Let me form a thoughtful analysis for the deliberation:

The distinction between flat and nested configuration structures is fundamentally about coupling and tool maturity. Currently, the memory plugin hardcodes settings in TypeScript constants—configuration is implicit and embedded in the codebase. Migration to external settings creates an opportunity to choose the right structure for *how hooks will consume it*.

**System-level constraints:**

Hooks operate in a constrained environment with specific performance targets (SIMPLE_HOOK_MS: 100ms, SEMANTIC_FALLBACK_MS: 2000ms). They invoke via stdin/stdout with minimal dependencies. Nested YAML adds parsing complexity—you need a YAML parser, schema validation, and error recovery within those millisecond budgets.

Flat YAML avoids intermediate parsing: `ollama_chat_model: gemma3:4b` can be extracted via `grep "ollama_chat_model" config.yaml | cut -d: -f2`. This is resilient to parser bugs and works under resource constraints.

**Architectural coupling:**

Nested structure couples hook consumers to your information architecture. If you later split "Ollama" settings into "embedding-service" and "chat-service", you're renaming keys that hooks depend on. Flat keys namespace this better: `ollama_embedding_timeout_ms` doesn't create pressure to restructure when the system evolves.

However, nested structure documents the *intent*—that Ollama settings belong together, that performance thresholds are a coherent group. This clarity matters when you're adding new hooks or someone new reviews the config.

**The practical middle ground:**

Flat YAML for *storage and hook consumption*, but generate nested documentation and validation schemas from it. Store as:
```yaml
ollama_chat_model: gemma3:4b
ollama_embedding_model: embeddinggemma:latest
performance_simple_hook_ms: 100
performance_ollama_hook_ms: 200
```

Provide a schema.json that shows the logical grouping, and a `validate-settings.ts` utility that proves configuration is complete. This gives you grep-safe consumption, low hook overhead, and clear documentation of relationships.

The hooks never parse YAML; they source the file as shell variables. The system tooling (validation, schema generation, documentation) handles the nested view.

### 2026-01-17T11:12:07.006Z - Counter-argument (model:haiku style:Devils-Advocate [af62675f-a669-4c75-af16-c65eeb51951e])
Settings proliferation creates hidden failure modes. A user misconfigures hook behaviour or memory storage paths, and the plugin silently degrades - no errors, just missing captures or lost context across sessions.

You're adding configuration surface area that scales with every new feature. Each setting becomes a support burden: "Why isn't my memory persisting?" when they've disabled the auto-save hook without realising the consequences.

Default-everything is simpler but inflexible. Configurable-everything is flexible but unsafe. The middle ground is harder to maintain - you need sensible defaults that work 90% of the time, with escape hatches only for genuinely justified cases. But how do you enforce that boundary?

Consider: does the user actually need to configure these hooks, or are they just asking because it feels like the right thing? Memory hooks should work consistently across all Claude sessions in a project. The moment you let users toggle them per-session or per-agent, you risk inconsistent memory state - some agents capturing learnings, others not, fragmenting the knowledge base.

What if settings become stale? A user configures something in week 1, forgets about it, and then spends hours debugging why the plugin behaves differently than expected in week 5.

The strongest design might be: fixed, sensible defaults that the plugin maintains, with a minimal configuration surface for only the cases that genuinely justify it (e.g., memory storage path for special environments). Everything else should be inferred from context.

### 2026-01-17T11:12:53.703Z - Alternative
Alternative approach: Environment variables for service settings (OLLAMA_HOST is already standard). Trade-offs: ENV vars are global, not per-project; .local.md is project-scoped. ENV for services, .local.md for behaviour customisation?

### 2026-01-17T11:13:40.222Z - Thought
UX consideration: Zero-config happy path is essential. Plugin must work without any .local.md file. Settings file is for power users who want to override defaults or use custom Ollama endpoints.

### 2026-01-17T11:15:23.818Z - Thought
Codebase analysis found 50+ hardcoded settings across hooks. Key categories:
- Ollama: host, models, timeout, context window (HIGH priority for user config)
- Semantic thresholds: 0.4-0.55 for different hook types (MEDIUM priority)
- Performance: hook timeouts 100ms-600s (LOW priority - internal tuning)
- Weights: relevance scoring weights (LOW priority - advanced tuning)
- Limits: result counts, preview sizes (LOW priority)

User-facing settings should be minimal. Most settings are implementation details.

### 2026-01-17T11:16:04.717Z - Thought (model:haiku style:Architect [cd239a73-77f1-4f13-b186-9f3f861bdb14])
Let me try the correct approach for this deliberation:

Configuration versioning becomes critical as the plugin evolves. The tiered approach prevents sprawl, but introduces a new problem: backwards compatibility with user configurations. When plugin updates change default behaviours or add new settings, users upgrading won't get the changes if their .local.md files have stale values.

The architectural principle here is **explicit over implicit**. Rather than silently using defaults, the plugin should:

1. **Validate on load** - Check if user config is from an older plugin version (include a `config_version` field)
2. **Report drift** - If deprecated settings exist, log warnings to memory with migration guidance
3. **Fail safely** - Invalid settings should default with explanation, not silently degrade
4. **Document the contract** - Make it clear what happens when settings are removed

This mirrors how serious tools handle this (Node.js package.json, Postgres configs). The Tier 1/2/3 split is sound, but needs a fourth consideration: **How will we communicate breaking changes to users without cluttering their workflows?**

The memory system itself is the perfect venue - capture the change log there. Users who run `/memory check-gotchas` discover "settings changed in v2.0" without intrusive warnings.

This also prevents the common failure mode: users copying old configurations from old plugin versions and never knowing they're running degraded functionality.

### 2026-01-17T11:16:36.831Z - Thought
User input: Model choice is primary use case. Users want gemma3:4b, gpt-oss:20b, or other models. Power user feature. Override chain: .local.md > plugin defaults. Graceful fallback on errors.

### 2026-01-17T11:16:54.555Z - Conclusion
Decision: Implement plugin settings via .claude/memory.local.md with tiered configuration.

FILE FORMAT:
- YAML frontmatter + markdown body (per Claude Code pattern)
- File: .claude/memory.local.md
- Add to .gitignore template

TIER 1 SETTINGS (Exposed):
- enabled: boolean (default: true) - master switch
- ollama_host: string (default: http://localhost:11434)
- chat_model: string (default: gemma3:4b)
- embedding_model: string (default: embeddinggemma:latest)
- context_window: number (default: 16384)

TIER 2 SETTINGS (Advanced, documented):
- health_threshold: number (default: 0.7) - graph health warning
- semantic_threshold: number (default: 0.45) - similarity cutoff
- auto_sync: boolean (default: false) - sync on startup

IMPLEMENTATION:
1. Create settings-parser.ts utility to parse YAML frontmatter
2. Update hooks to read settings with fallback chain
3. Create memory.example.md template
4. Document in plugin README

ERROR HANDLING:
- Missing file → use plugin defaults (zero-config happy path)
- Parse error → log warning, use defaults
- Invalid value → log warning, use default for that setting
- Ollama unavailable → graceful degradation (already handled)
