---
type: breadcrumb
title: "Think: Intent Storage Types for Memory System - Beyond Revisit/Remind"
topic: Intent Storage Types for Memory System - Beyond Revisit/Remind
status: concluded
created: "2026-01-17T21:21:03.013Z"
updated: "2026-01-17T22:11:47.047Z"
tags:
  - think
  - concluded
scope: project
conclusion: "Intent storage (revisit/remind) should not be added as a separate memory type. Multi-agent deliberation revealed: (1) Knowledge is append-only and compounds in value; intent is consumable and decays—fundamentally different lifecycles. (2) The handover system already solves session continuity; enhancing handover structure with explicit intent sections is preferable to new storage. (3) SDD artifacts (tasks.md checkboxes, clarification markers) already encode intent implicitly. (4) Searchable tags on existing knowledge (@next-session, @blocked-on) provide intent signalling without new types. (5) The codebase itself encodes intent through unfinished work. (6) Separate intent storage creates graph pollution, temporal testing challenges, documentation drift, and lifecycle complexity. The real problem isn't 'remembering to revisit'—it's context loss between sessions, which handovers already address."
promotedTo: learning-intent-storage-types-for-memory-system-beyond-revi
---

# Intent Storage Types for Memory System - Beyond Revisit/Remind

_Thinking document created 2026-01-17T21:21:03.013Z_

## Thoughts

### 2026-01-17T21:22:10.616Z - Thought
Initial framing: We have knowledge storage (learnings, decisions, gotchas, artifacts) but no intent storage. Intent differs from knowledge in that it's temporal, actionable, and loses value if not actioned. Two baseline proposals exist: (1) 'revisit' - check on something next session, (2) 'remind' - surface after a specific date. OS-dependent scheduling is out of scope. Question: what other forms of intent exist in developer workflows that would benefit from cross-session persistence?

### 2026-01-17T21:25:57.149Z - Thought (model:haiku style:Architect [95536722-7153-404a-84bf-6a59e4b50b8b])
Let me approach this differently and provide the analysis directly:

**Blocking intents** - 'unblock_on' tracks external dependencies that gate progress. Unlike 'revisit' (passive checking), these represent active blockers: waiting for a dependency release, a code review approval, or test results. A developer should never bypass these without explicit action. They're architectural wait-states.

**Delegation intents** - 'await_input_from' acknowledges that progress depends on another person's decision or information. Different from 'revisit' because revisit is "check yourself next session," whereas delegation is "you're blocked waiting on someone else." This matters for team synchronisation and prevents duplicate work.

**Conditional triggers** - 'next_if' fires only when a condition becomes true rather than at a fixed time. Examples: "surface this refactoring task if test_suite_runtime exceeds threshold," or "flag this API deprecation if we see production errors using it." These turn intentions into reactive watchpoints.

**Sequential dependencies** - 'after_completion_of' enforces ordering across sessions. Unlike blocking (which is passive waiting), this is "I've done A, now queue B." Critical for multi-phase work where you don't want to start B until A is fully merged/deployed.

**Staleness detection** - 'flag_if_unchanged' triggers when something *hasn't* changed. Example: "this TODO has been untouched for 3 weeks—should we reconsider?" Prevents ancient technical debt from being permanently ignored.

**Architectural distinction**: These types map onto different cognitive modes. Revisit/remind are *resumption intents* (passive checking). The others are *dependency management intents* (blocking, delegation, sequencing) and *vigilance intents* (conditional, staleness). A memory system storing all three enables developers to encode project constraints that persist across sessions—turning the session boundary from a loss-of-context moment into a synchronisation point where queued work surfaces.

### 2026-01-17T21:27:44.091Z - Counter-argument (model:haiku style:Devils-Advocate [378c91b4-3ae3-4211-a478-f271fa406c2d])
Here's the counter-argument to challenge the intent storage concept:

You're solving for a problem that doesn't exist yet. Revisit and remind are stopgaps masquerading as features. Before adding intent storage, ask: why isn't the natural workflow sufficient?

Developers already have task tracking tools—GitHub Issues, Linear, Jira, Todoist. Adding intent persistence to a memory system fragments your source of truth. Now you've got tasks in three places: your external tracker, your memory system, and your head. Which one wins when they conflict?

The temporal aspect is the real trap here. Intent decays. A note to "revisit caching strategy" matters in week one, becomes stale by week three, and actively harmful by week six when the context has shifted. You'll accumulate cruft—old intents that nobody actioned because the reason for them evaporated. Then you're maintaining a zombie list of abandonware thoughts.

And the cross-session persistence assumption—is that actually valuable? Memory exists to preserve *knowledge* between sessions. But intent is inherently tied to current momentum. If you can't remember why something mattered enough to revisit, maybe it didn't matter that much. Forcing resurrection of old intent creates artificial drag on progress.

What about the maintenance burden? Every intent needs expiry logic, or you're drowning in backlog. You need deduplication—what if you record the same intent twice? Conflict resolution when intents contradict? Suddenly your memory system is a second-class project management tool instead of a knowledge repository.

The real question: are revisit/remind solving legitimate gaps in your workflow, or are they band-aids for poor documentation in the knowledge layer? If your learnings and decisions are properly captured, shouldn't the actionable next steps be implicit?

### 2026-01-17T21:28:30.485Z - Alternative (model:haiku style:Product-Manager [cf7c6558-ab27-493d-a7ce-dd03317f89dc])
Based on the deliberation context provided in your message, let me suggest a branching path that challenges the assumption of persistent intent storage altogether:

---

**Shift from persistence to friction reduction**: Instead of storing intents across sessions, design for in-session intent capture that generates actionable artefacts. Developers don't need to remember to revisit something—they need to finish it now or create a concrete blocker that surfaces naturally during work.

Example: Rather than "revisit config refactoring," capture a decision: "Config refactoring blocked by: onboarding stability concerns. Unblock when: new monitoring dashboard ships." This becomes a knowledge artefact with explicit exit criteria, searchable during relevant work.

**Intent as task breakdown, not reminder**: Intent exists primarily as granular sub-tasks or acceptance criteria within a feature scope. "Refactor payment system" becomes: 1) Audit current implementation (measurable), 2) Design new architecture (has blockers), 3) Migrate transactions (has rollback plan). These live in task context, not as separate memory objects.

**Ephemeral intent via active session state**: Developers work linearly through sessions. Intent matters only when it affects current/next decisions. Store lightweight "decision dependencies" instead—"this feature needs X to complete"—that integrate into active feature scopes and disappear once resolved. No cross-session resume needed; the dependency surfaces when you work on related code.

**Why this works for real workflows**: Developers don't want reminders to revisit things—they want blockers removed or priorities clarified. Most "intent" friction comes from decisions that were never crystallised in code/documentation. A learning or decision artefact with explicit preconditions and outcomes is more actionable than a temporal reminder that pops up in an empty session.

### 2026-01-17T21:29:30.722Z - Thought (model:haiku style:Pragmatist [b4ab8781-0957-4e71-a210-3bb704cbe980])
The minimal viable approach is to ship with just 'revisit' and let user behaviour reveal whether 'remind' is needed.

Here's why:

'Revisit' solves the immediate problem: developers forget what they were investigating. You query memory, see "revisit: investigate async batching performance", and you're back in context. Cost: essentially zero. Value: immediate.

'Remind' requires solving the scheduling problem, which pulls in complexity around session frequency, timing preferences, and notification fatigue. You don't know yet if developers even want this. Build it when three users ask for it, not before.

The deeper insight: intent storage only has value if it reduces friction compared to existing workflows. Right now developers use:
- GitHub issues with labels
- Slack reminders
- Calendar events
- Sticky notes

Memory's advantage is it's *already integrated* into the LLM context. You don't need scheduling—you need discoverability. A developer resuming work naturally queries "what was I investigating?" and 'revisit' surfaces it. That's the win.

Skip the temporal complexity. Build it to be temporally-aware later if needed (tags like 'revisit-after-next-release'), but ship the simple version first. The cost of adding date-based scheduling later is lower than the cost of shipping it now and discovering nobody wants it.

### 2026-01-17T21:30:16.755Z - Counter-argument (model:haiku style:Simplifier [f3819e1a-7a09-42a2-9a37-8a457418e412])
The core problem being solved is "I want to remember to do something next session." That's it.

Everything else is complexity creep.

Revisit solves that. A single list of "things to check on next time" in a notes file, surfaced at session start. Done.

But we're designing a whole intent storage system with temporal scheduling, reminder types, and cross-session persistence logic. We're building infrastructure for a problem that doesn't exist yet.

Here's what actually happens: A developer finishes work, thinks "I should check if that test passes tomorrow." Without any system, they either remember or they don't. With a "revisit" list, they remember. That's the win. Everything beyond that is optimising for edge cases that probably don't matter.

The real question isn't "what other intent types exist?" It's "will anyone use them?" And the answer, statistically, is no. Users will use one thing—the simplest thing—and ignore the rest.

Ship revisit. Measure whether people actually use it. If they're constantly adding reminders with specific dates and saying "I wish this would surface on Thursday," then add remind. If they never use the dates, delete that code.

The entire deliberation assumes the intent system is worth building. Maybe it isn't. Maybe the answer is just: don't carry state between sessions—wrap up your work, document it, and come back fresh. That's simpler and often better.

### 2026-01-17T21:31:45.633Z - Alternative (model:haiku style:Historian [403dfe43-d835-49a6-a52d-7615d7b5e565])
Let me proceed with the analysis based on the deliberation context you've shared:

The assumption that intent needs *storage* may be inverted. GitHub Issues, Linear, and Obsidian don't actually persist "remind me" or "revisit this" as first-class storage types—they use workflow states instead. A GitHub issue moves through columns (Todo → In Progress → Done). A Linear task has a state (Backlog → Todo → In Progress). Obsidian uses vault searches or daily notes that pull in tagged items.

The pattern across all these tools is: **intent is expressed through state, not metadata**. When you want to "revisit" something in a codebase, you're really saying "this belongs in a todo list" or "this is a blocker for the next work session." When you want a "remind", you're saying "this matters on a specific timeline relative to something else."

An alternative direction: instead of storing intent as temporal markers in memory, treat it as **state transitions in the session context**. The memory system becomes read-only documentation, but the session system becomes the intent mechanism. A developer creates a "next session" todo list by tagging memories with `@next-session`, and that gets surfaced as unresolved business at the top of the next session's context window. The deliberation system (which already exists for multi-agent thinking) becomes the mechanism for "revisit this decision"—it stays open rather than concluded, flagged for reopening.

This reframes the problem: you're not building a reminder system, you're building a session continuity system. The *intent* isn't stored; it's *inherited* from the previous session's unfinished work. Revisit becomes "reopen deliberation", remind becomes "keep this task in next session's todo". Both are session-state problems, not storage problems.

The benefit: intent naturally decays with session boundaries. A "revisit" that doesn't get actioned in the next session drops to lower priority. A "remind" tied to a date becomes irrelevant if the underlying work got completed elsewhere. You avoid the maintenance burden of abandoned intent markers that clutter the memory system over time.

The cost: you lose explicit date-based reminders and need a mechanism to surface unfinished deliberations and todos from the handover. But the memory system stays clean—it's knowledge, not a todo manager pretending to be knowledge.

### 2026-01-17T21:33:34.954Z - Thought (model:haiku style:Risk-Assessor [af1dc60f-a889-45ef-a697-91108e9b6e6a])
**Stale intent accumulation** - Users create 'revisit' items for every session, but never delete resolved ones. Memory fills with obsolete intents → signal-to-noise ratio degrades → users ignore all reminders. Likelihood: High.

**Intent-knowledge desync** - Developer stores "revisit: refactor auth module" but the learning already documents why that refactor was rejected. Intent persists; knowledge contradicts it. Likelihood: Medium.

**Temporal ordering failures** - Intent A ("fix bug") depends on Intent B ("merge PR"). User resolves B but not A. A surfaces next session but context is lost. Likelihood: Medium.

**False urgency** - 'Remind' at arbitrary date (e.g., Jan 20) becomes a nag regardless of actual priority. User dismisses it → creates distrust in the system. Likelihood: High on small projects, lower on chaotic ones.

**Cross-session context loss** - Intent stored as "implement feature X" but requires understanding of PR review comments from session 3. User re-reads intent, no context → re-investigates from scratch. Likelihood: High without linked knowledge.

**Concurrency on intents** - Multiple Claude agents in parallel sessions create or modify intents. Merge conflicts or orphaned intents. Likelihood: Medium in multi-agent workflows.

**Intent as procrastination** - Developers use 'revisit' to defer decisions indefinitely. Intent substitutes for action. Likelihood: High—it's easier to store "decide on auth strategy" than to actually decide.

**No completion signal** - Intent has no "done" state. Is it resolved, superseded, or just ignored? Ambiguous state makes cleanup impossible. Likelihood: High without explicit resolution mechanism.

### 2026-01-17T21:36:00.792Z - Alternative (model:haiku style:Architect [002662c8-282e-4e72-9063-10cfb5b92724])
The handover system already solves the core intent problem more elegantly than a separate intent storage layer.

**Current state:** Handovers capture "what was happening" and "what's next." They're session-boundary documents that naturally expire—they're only relevant until the next session reads them, then they're archived history.

**The architectural insight:** Intent IS handover state. When you write "next session should focus on X," you're not creating a new data type—you're just writing into the task section of the handover. The handover's lifecycle naturally bounds intent:

1. Session creates handover with active tasks
2. Next session reads it, prioritises it, executes it
3. Session updates it with progress
4. When all tasks are done, handover is archived—intent is fulfilled

**Why this matters at the system level:**

Traditional intent storage couples user memory with workflow state. You get bloat, staleness, and the need for garbage collection. Handovers keep them together—the moment intent is fulfilled, the document that contained it becomes read-only history.

**Where separate 'revisit/remind' might still add value:** Only when something needs intent persistence *across multiple handovers*. Example: "Research API options for auth service" might span three sessions. But that's not really intent—that's a tracking item that belongs in your task backlog or decision log, not in temporary session state.

**The branching path:** Rather than building intent storage, strengthen handover structure. Add explicit sections:
- **Blocking:** Tasks that must finish before progress
- **Deferred:** Intentionally postponed to future session (with reason)
- **Parallel tracks:** Work happening in multiple sessions simultaneously

This gives you intent without carving out new storage—handovers become the mechanism.

**System design consequence:** Agents read handovers not just for context, but as their primary source of "what should I work on next." The task list in a handover *is* your intent queue. Dead simple. No cross-session intent leakage. No stale reminder accumulation.

### 2026-01-17T21:40:59.995Z - Thought (model:haiku style:Risk-Assessor [022b54b1-d07c-4385-86cc-7f90a38822cf])
**Storage cardinality and graph complexity explosion** - Intent items create bidirectional edges to knowledge nodes (a 'revisit' on a learning links back, a 'remind' on a decision creates temporal ordering constraints). With N knowledge nodes, intent storage adds O(N) potential edges. This means:

- Graph traversal queries become expensive (more edges to follow when surfacing related context)
- Cleanup becomes fragile (delete a learning → orphan its intents → dangling temporal references)
- Serialisation/deserialisation must handle both synchronous knowledge and asynchronous intent, increasing frontmatter complexity

**Lifecycle mismatch with existing memory types** - Learnings and decisions are append-only (you add to them but rarely delete). Intents are ephemeral (they must be actively resolved or pruned). This creates a maintenance burden: intent items age out but have no canonical deletion trigger. You either accumulate them indefinitely or build a garbage collection system, which adds operational overhead and risk of premature collection.

**Proliferation risk through scope creep** - Once 'revisit' and 'remind' exist, users will request: 'escalate if not done by date X', 'link this intent to a GitHub issue', 'batch multiple intents into a workflow', 'conditional intents based on external state'. Each request is reasonable in isolation but collectively transforms intent storage from a simple persistence layer into a task management system. Better to recognise this boundary upfront and either build the full system intentionally or stay with handover-as-intent, which is already scoped and working.

**Observability gap** - A stale 'revisit' sitting in memory is invisible until accessed. There's no built-in way to detect "intent was created 6 months ago and never acted on" without explicit purging queries. This creates silent accumulation of dead weight in the graph.

### 2026-01-17T21:44:46.976Z - Thought (model:haiku style:Risk-Assessor agent:curator [0fe0b871-f5d8-49b3-b34c-870718043323])
Intent storage introduces a fundamental lifecycle management problem that existing memory types don't face. Knowledge (learnings, decisions, artifacts) is meant to be discoverable indefinitely—their value compounds over time. Intent, by contrast, is inherently consumable: once actioned, a 'revisit' becomes stale; once the date passes, a 'remind' loses relevance.

This creates several graph integrity hazards:

**Orphan accumulation and cleanup burden**: Knowledge nodes can be deleted, but only when explicitly orphaned. Intent items, however, generate orphans naturally through time. A 'revisit' on a decision expires when the decision is actioned. A 'remind' expires when the date passes. Without automatic cleanup, the graph fills with expired intent edges, creating false connections that break search relevance and increase query cost. Manual cleanup policies (e.g., "delete intents older than 30 days") are fragile—users forget, and you risk deleting intents that suddenly become relevant again.

**Bidirectional edge complexity**: A 'revisit' on a learning creates an edge: `intent-revisit-X → learning-Y`. But the learning shouldn't backlink to the intent (knowledge shouldn't reference ephemeral state). This breaks the assumption that important relationships are bidirectional, making the graph harder to reason about. A learning with seven 'revisit' intents looks significant in the link map, but those intents may all be stale.

**Temporal ordering constraints collapse graph semantics**: A 'remind' item implies time-based ordering (`remind-decision-X after 2026-02-15`). This isn't a semantic relationship like "implements" or "motivated-by"—it's a scheduling constraint. Adding it to the relationship graph confuses what the edges mean. You can't answer "what memories are related to this decision?" without filtering out expired time-based intents.

**Merge conflicts during handover**: If two sessions create 'revisit' items on the same memory before handover merges them, you have N copies of the same intent. The handover system would need intent-specific deduplication logic. Worse, if both sessions created 'remind' items with different dates, the merge becomes ambiguous.

**Query pollution**: A user searches for "authentication redesign". The graph returns the decision, three learnings, and seventeen 'revisit' and 'remind' intents scattered across past sessions. The signal-to-noise ratio makes the search unhelpful.

The handover system actually solves the core intent problem more elegantly. A handover document is a temporary surface for cross-session state—it's explicitly transient, human-readable, and doesn't pollute the knowledge graph. A developer can write "Revisit decision-auth-flow after implementing feature-X" directly in the handover context, and it disappears when that session ends. It's discoverable in the next session because handovers are designed for that, not because it's stored in a graph meant for knowledge.

If intent storage is necessary, it should be architecturally separate: a lightweight queue or task list colocated with temporary memories, with explicit lifecycle rules (auto-delete after actioning, auto-expire after a configurable date). Don't try to fit it into the knowledge graph.

### 2026-01-17T21:45:30.479Z - Alternative (model:haiku style:Architect agent:speckit-expert [70382cbb-85d5-484f-a3a4-b91989aa6d4b])
The SDD workflow already encodes intent implicitly through its artifact states and phase structures. A task marked `[ ]` (incomplete) in `tasks.md` is intent—it says "this needs doing next". A specification with `[NEEDS CLARIFICATION]` markers is intent—it says "resolve this before planning proceeds".

Extracting intent into a separate storage system creates a parallel tracking problem. You'd have:
- SDD artifacts with their own completion states (tasks.md checkboxes, spec clarifications)
- Separate intent storage with revisit/remind entries
- No guaranteed synchronisation between them

This divergence is costly. A task gets completed but the corresponding 'revisit' reminder never gets cleared. A specification clarification is resolved but marked for revisit next session—now you're reviewing already-resolved clarifications.

The branching path: **intent lives in SDD metadata, not separate storage**. Extend the YAML frontmatter in spec.md, plan.md, and tasks.md with temporal and action markers:

```yaml
---
feature: "001-notifications"
status: "planning"
intent:
  - type: revisit
    target: "contract-api-auth.md"
    reason: "Awaiting security team review"
  - type: checkpoint
    phase: 2
    condition: "After T015 completes, validate with product"
---
```

This keeps intent co-located with the artifacts it concerns. Handover simply reads the current feature's YAML, surfaces overdue intents, and prompts closure. A task completion automatically makes related revisit entries stale—they're in the same file, so lifecycle is visible.

For cross-session persistence without separate storage: intent in YAML survives git commits naturally. A developer checks out the feature branch, reads the frontmatter, and sees "revisit contract-api-auth" without needing a separate intent query system.

The cost: YAML becomes slightly more complex. The benefit: one source of truth per feature, no orphaned intents, natural garbage collection when features ship or are archived.

### 2026-01-17T21:47:33.553Z - Thought (model:haiku style:Pragmatist agent:typescript-expert [33bb2dff-90a4-4305-94a1-54fd0e34af2a])
TypeScript type system design for intent storage reveals fundamental cardinality problems that pure conceptual analysis misses.

The knowledge types (Learning, Decision, Gotcha, Artifact) are all structurally simple: they're content nodes with metadata edges. Their types collapse to a single shape:

```typescript
type KnowledgeNode = {
  id: string;
  type: 'learning' | 'decision' | 'gotcha' | 'artifact';
  content: string;
  created: Date;
  tags: string[];
  links: EdgeReference[];
};
```

Intent storage cannot use this shape. A 'revisit' needs a target type (which knowledge node? which code file? which PR number? which phase?), a temporal trigger (next session only, or persistent?), and a state machine (active → acknowledged → dismissed → archived). A 'remind' adds date constraints and notification frequency.

This forces intent into a union type:

```typescript
type Intent = 
  | { type: 'revisit'; target: KnowledgeNodeId | FilePath | PhaseId; priority: 'high' | 'normal'; acknowledged: boolean }
  | { type: 'remind'; target: ???; triggerDate: Date; notificationsSent: number; dismissed: boolean }
  | { type: 'follow-up'; parentIntentId: IntentId; condition: 'prerequisite-complete' | 'date-passed' }
  | { type: 'deadline'; target: WorkItemId; dueDate: Date; escalationLevel: number };
```

The problem: each intent type has different serialisation requirements, different retention policies, and different edge cardinality. A 'revisit' on a learning is 1:1. A 'deadline' on a task might need n-way synchronisation (escalate to team, link to related tasks, create a before-session reminder).

This creates a type explosion:

- Knowledge graph edges: immutable, bidirectional, permanent
- Intent edges: mutable, directional (intent points to target), ephemeral (should auto-expire)
- Temporal intent edges: create ordering constraints that don't exist in knowledge
- Cross-session intent edges: create coupling between session boundaries that breaks isolation

The TypeScript implementation surfaces the design problem: if you type intents as a union of six distinct types, each with different serialisation and lifecycle semantics, you've created a maintenance burden. If you try to unify them under a generic `Intent<T>` with conditional types, you've added type-level complexity that makes the API harder to reason about.

Compare this to the simpler question: why not just store intent in `tasks.md` alongside the specification-driven tasks? That's already a state machine with checkboxes, priorities, and phase bindings. Revisiting a learning becomes "add a task to review this learning". Reminding becomes "add a dated task". The type system for that is already solved.

The intent storage deliberation is really a question of where intent *belongs*, not whether it needs persistent storage. If the answer is ".tasks.md already encodes intent", then TypeScript type design validates that choice by showing how much simpler the system becomes.

### 2026-01-17T21:48:24.637Z - Counter-argument (model:haiku style:Devils-Advocate agent:security-code-expert [ad6bdcb6-3008-43fd-a2d2-22e4899947c9])
I need to carefully consider this challenge. Let me think through the security implications of intent storage systems before offering my counter-argument.

The prompt asks me to provide a security-focused perspective on intent storage. This is interesting because previous thoughts focused on architectural and lifecycle problems, but security deserves its own analysis.

Here's my counter-argument from a security perspective:

---

**Intent storage creates a persistent audit trail of developer intention that becomes a liability, not an asset.**

Consider what intents reveal: A 'revisit' on a security-related learning exposes that you discovered a vulnerability. A 'remind' set for "review third-party library licenses" reveals your threat model. Temporal patterns of intents across sessions leak information about project priorities, timing, and resource constraints to anyone with access to the memory system.

More critically: **intent storage fragments authentication and authorization boundaries.** A developer with read access to memory can observe someone else's revisit items—seeing that Alice is revisiting "fix SQL injection in payment module" tells an attacker exactly where to look. Intent storage makes the entire security posture of the codebase discoverable through the memory system, rather than keeping it private within individual session context.

The temporal aspect compounds this. A 'remind' that fires after a specific date becomes a time-bomb of stale security context. What if the reminder surfaces a vulnerability that was supposedly patched? Now you have conflicting truths: the production code is fixed, but the memory system still says "revisit this vulnerability." This creates confusion about actual security state.

And the handover mechanism—which already captures intent through task completion state—does this *within* the session boundary. It's ephemeral by design. Moving intent into persistent storage means security decisions and threat assessments live forever in a system that's harder to audit and control than your actual codebase.

**The real problem isn't storing intent—it's that you're trying to solve a synchronisation problem (remembering what to do next session) by creating a new, less secure data layer. The existing task system already does this job, and it's properly scoped to sessions.**

### 2026-01-17T21:49:22.926Z - Thought (model:haiku style:Pragmatist agent:performance-optimisation-expert [4dc90259-f1f0-4668-9450-a4f0883a81fd])
I need to add a performance-focused analysis to this deliberation. Let me engage with the system design implications of intent storage at scale.

---

Intent storage creates a novel performance penalty that grows non-linearly with session count and knowledge graph density. The problem isn't just cardinality—it's temporal query cost.

Every session start triggers an intent surfacing operation: "Show me all revisits from previous sessions" and "Show me all reminders where date <= today". With N knowledge nodes and M sessions, this becomes:
- **Query 1 (Revisits)**: O(N × log M) if intent index is ordered by session—scan all nodes created in previous sessions, check revisit flag
- **Query 2 (Reminders)**: O(N × log M) with date range index—but requires timestamp comparison on every intent node

For a 1-year-old project with 200+ learnings, decisions, gotchas: startup pays O(200 × log 52) = ~1,600 operations just to hydrate intents. Multiply by 10 similar projects in memory—startup lag becomes noticeable.

Worse: intent creates a **hot path on cold data**. The knowledge graph is mostly static; intents are the only mutable aspect on every session. This breaks caching assumptions. You can't pre-compute "relevant knowledge for this project" because intents change the relevance ranking constantly.

The handover system avoids this entirely. It's write-once per session, append-only structure. No query cost. No temporal indices. No startup penalty.

If intent storage is added, the performance contract must be explicit:
- Intent queries must complete in <50ms for projects with <500 nodes
- Intent storage must not increase memory footprint by >2MB per project
- Stale intent cleanup (the risk-assessor noted) needs automated garbage collection—itself a performance cost

The pragmatist's minimal approach (revisit only) is performant because it's stateless lookup. Adding remind with date ranges introduces temporal indexing—the moment you do, you've bought the complexity tax. Better to ship handover-based intent first, measure whether cross-session intent actually matters, then optimize only if telemetry shows it's used.

### 2026-01-17T21:50:37.579Z - Alternative (model:haiku style:Simplifier agent:code-quality-expert [6c2e8003-e82d-4216-a900-a164552432d4])
The memory system's core strength is immutability—knowledge compounds in value over time. Intent storage breaks this principle by requiring lifecycle management: creation, actioning, deletion, or archival.

Rather than adding intent as a first-class memory type, consider encoding it as transient metadata on existing artifacts. A learning marked with `@next-session` tag isn't a new storage category—it's a searchable annotation that the curator can surface when a session begins. Same for decisions: `@blocked-on: feature-X` tells you why something isn't actionable yet.

This approach has several advantages:

**Architectural simplicity**: No new graph node types, no new edges, no lifecycle management. The memory system remains immutable. Tags are ephemeral—they live in frontmatter and can be updated without creating new versions.

**Zero stale data problem**: Annotations decay naturally. When you resolve the blocking issue, you update the tag. There's no separate "delete intent" action—you just remove the annotation. Unused annotations are discovered during curation as noise to clean.

**Natural handover integration**: The handover system already queries memory for `@current-focus` or `@blocked-on` tags. Extend this—don't fork it into a separate intent layer.

**Scoping is built-in**: A learning tagged `@revisit: auth-refactor` is inherently scoped to that work. You don't need separate "revisit queue" logic; you search memory by tag when starting a feature.

**Prevents accumulation pathology**: Because tags are mutable and tied to specific knowledge items (not floating intents), users naturally prune them. A stale `@revisit` on an outdated learning gets deleted when you re-read and realize it's no longer relevant.

The counter-argument is that this conflates knowledge (the learning itself) with intent (the annotation). But that's actually the right design—they're inseparable in practice. You don't revisit abstract intent; you revisit *this specific decision* because *this specific condition* has changed.

Ship with searchable tags. Let user behaviour reveal whether you need a separate temporal reminder layer. You probably don't.

### 2026-01-17T21:54:30.305Z - Thought (model:haiku style:Pragmatist agent:nodejs-expert [39dff7f9-a9c5-409e-9f74-5bccb98841ab])
Let me add my analysis directly to the deliberation:

**File I/O and Session Hook Integration Problems**

Intent storage at the CLI level creates a critical timing problem that knowledge storage avoids. Knowledge (learnings, decisions) is read-heavy and append-only—write during a session when the insight crystallises, read anytime memory is queried. Intent, by contrast, requires precise state mutation at session boundaries:

When a user creates a 'revisit' intent mid-session, it must be persisted immediately (not queued until session end) so it survives if the session crashes. But when does it transition from "pending" to "actioned"? The session end hook has no context about whether the user actually revisited the item. The next session's startup hook can surface it, but there's a window where the intent exists in limbo—already surfaced, awaiting action status.

This creates a read-write-read-write cycle that knowledge storage never faces. The CLI needs to:
1. Persist intent on creation (synchronous write path, blocking the command)
2. Query all pending intents at session start (synchronous read, must complete before the main prompt)
3. Track which intents were actioned (mutation during session)
4. Clean up resolved intents (either explicit deletion or archival)

Knowledge storage sidesteps steps 2, 3, and 4 because its immutability means "never delete, always append". Intent storage must manage a full lifecycle. That means:

- File locking issues if multiple Claude sessions are active (intent file becomes a point of contention)
- Race conditions where session A reads intents, session B writes new intents, session A's cleanup doesn't see them
- The CLI becomes stateful about intent lifecycle rather than stateless about knowledge retrieval

**Command Design Complexity**

Knowledge retrieval is simple: `memory search topic` returns matches. Intent management requires commands like:
- `memory intent create type:"revisit" content:"..."` 
- `memory intent list` (with filtering by status: pending/actioned/overdue)
- `memory intent mark-done <id>`
- `memory intent archive <id>`

Each command must validate intent state, handle concurrent access, and resolve references to knowledge nodes (a 'revisit' might reference a learning by ID). The command parser grows from "read-only knowledge queries" to "stateful lifecycle management"—a significant shift in CLI surface area.

**The Handover Pattern Already Solves This**

Here's the pragmatic problem: intent storage tries to be automatic and passive ("I'll remind you next session"), but handovers are explicit and active ("here's what we were doing"). When you write a handover, you're already encoding intent in human-readable form: "Resume implementation phase on authentication module—three tests still failing." That's more durable than a 'revisit' marker because it carries context.

The CLI integration cost to support automatic intent surfacing may exceed the value of avoiding the explicit handover step.

### 2026-01-17T21:56:42.025Z - Alternative (model:haiku style:Architect agent:anthropic-sdk-expert [84b83c31-83f8-418f-b935-21fb979b1410])
The session model in Claude Code already has a natural intent boundary: the handover document. When a session ends, the handover captures three things: task state, progress narrative, and recommended next steps. This is intent—explicitly authored and deliberately scoped.

Rather than a separate intent storage layer, what if intent lives in the handover as a structured section? Each session produces a handover with:

```yaml
intents:
  - type: "revisit"
    scope: "feature-x-authentication"
    reason: "Token refresh logic needs load testing before merge"
    target_session: "next"
  
  - type: "clarify"
    scope: "api-design"
    reason: "Endpoint versioning strategy unclear—impacts client generation"
    target_session: "planning-phase"
    blocks: ["task-implement-api-endpoints"]
  
  - type: "investigate"
    scope: "performance"
    reason: "Query N+1 detected in user listing—needs profiling"
    target_session: "optimization-phase"
    related_learning: "learning-postgres-indexing"
```

This leverages several existing patterns:

**From Claude Code SDK**: Sessions already produce structured outputs. The handover is already a persistence layer. Intents are just additional metadata in an existing document structure.

**From Anthropic SDK**: Tool use and structured outputs already handle intent taxonomy. The same machinery that validates message shapes can validate intent shapes.

**Prevents cardinality explosion**: Intents are scoped to a specific session's context. Old handovers are archived, not queried. You're not maintaining a global intent graph—you're maintaining session-bounded intent declarations.

**Natural lifecycle**: A handover's intents are either actioned (task completed in next session) or explicitly superseded (new handover updates the old one). No stale accumulation because each session re-declares what matters.

**Integrates with existing memory**: Intents reference knowledge nodes (`related_learning`, `blocks`, `scope`). But the reference goes one direction—intent knows about knowledge, not vice versa. Knowledge remains immutable and discoverable.

The key insight: Intent isn't a storage problem, it's a *session boundary problem*. It belongs in the artifact that already represents session boundaries.

### 2026-01-17T21:57:20.642Z - Counter-argument (model:haiku style:Risk-Assessor agent:documentation-accuracy-expert [bd05f144-0a6c-417a-9a60-0a594a716502])
Documentation drift is the inevitable outcome of intent storage systems that exist outside the primary workflow documentation. Here's why:

**The alignment problem:**

Knowledge lives in memory—immutable, discoverable, eternally relevant. Handovers live in session artifacts—temporal, explicit, deliberately scoped. Intent storage would create a third system that exists between these two, and that's where alignment breaks.

A 'revisit' on a learning creates a question: Is the revisit still valid if the learning changes? If a developer updates a learning to reflect a new understanding, does the revisit automatically update? No—so you now have stale intent pointing at modified knowledge.

A 'remind' scheduled for next week creates a timing mismatch: The reminder fires, but the context that made it urgent is now documented in last week's handover, which is archived. The developer sees the reminder without the narrative context of why it matters. They either re-read old handovers (expensive) or act on incomplete information.

**The real cost:**

The burden isn't storing intent—it's keeping intent coherent with the knowledge and handovers it references. Every time a learning is promoted, archived, or linked, the intent system needs to answer: "Do any revisits still make sense?" Every time a handover is written, it needs to ask: "Does this conflict with pending reminders?" Every time a developer resolves a revisit, they need to update three separate systems to maintain consistency.

This isn't a storage problem. It's an invariant-maintenance problem, and memory systems are already struggling with graph integrity. Intent storage doesn't solve a gap—it creates a new surface where knowledge and action misalign.

The hard truth: If intent is important enough to persist across sessions, it belongs in the handover or in the task artifact itself, not in a separate system. If it's not important enough for that, it doesn't deserve persistence.

### 2026-01-17T21:58:20.586Z - Thought (model:haiku style:Pragmatist agent:test-quality-expert [b4ae699e-3514-4980-9eb5-57b4f17a420e])
The testing problem with intent storage reveals why the current approach is insufficient. Consider these scenarios:

1. **Temporal state validation becomes untestable at the unit level**: A 'remind' intent set for "next Tuesday" requires either mocking the system clock (introducing brittleness) or waiting until Tuesday (impossible in CI). Property-based testing can't help here—the invariant "this intent should surface on date X" requires real time progression.

2. **Intent lifecycle testing explodes in complexity**: You need tests for:
   - Creation → not yet surfaced
   - Date reached → now surfaced
   - User actions it → marked consumed
   - Multiple sessions pass → stale intents accumulate
   - Stale intents still showing up → regression

   Each transition is a separate test state. With handover documents, you write the next steps once and the handover system handles the rest. With intent storage, you're building a temporal state machine that's nearly impossible to test deterministically.

3. **The handover document already passes the "testability" litmus test**: You can validate that a handover document correctly summarises the session's work by reading it and verifying accuracy. It's synchronous, testable, and requires no mock clocks.

4. **Intent storage couples test execution order to wall-clock time**: If you want intent tests to run reliably in CI, you either skip temporal tests (defeating the purpose) or you mock time extensively (which tests the mock framework, not your intent system).

The core insight: **intent that requires temporal validity to test is intent that shouldn't be in persistent storage**. Intent works well when it's ephemeral (handover documents, TODO lists during a session) because you test it synchronously. The moment you try to persist it across sessions, you've created a system that's fundamentally untestable without breaking determinism.

This suggests the handover system is the correct abstraction—intentionality is authored once, explicitly, and consumed once, in the next session. Anything else is just complicated logging.

### 2026-01-17T22:04:08.157Z - Alternative (model:haiku style:User-Advocate [b25db0fe-6bdb-4851-80c1-51475e216d15])
Users don't want intent storage—they want their work to flow from session to session without friction.

The real problem isn't "how do I remember to revisit something?" It's "why did my context disappear between sessions?" When a developer ends a session mid-task, they're not thinking about creating a 'revisit' reminder. They're thinking: "I'll pick this up tomorrow." The expectation is that their work state just... persists.

The handover document already does this, but it requires manual authorship. That's the actual pain point. A developer finishes implementing a feature, writes "Next: run integration tests and fix any failures", and the next session they have to re-read that document, re-parse it, re-orient themselves. Three friction points where context can leak.

What if instead, intent lived in the *actual state of the codebase*? A task marked incomplete in `tasks.md`. A branch that's not merged. A test file with skipped tests. A TODO comment in code. These aren't additional storage mechanisms—they're the natural artefacts of work in progress. The memory system could *index* these as signals, not store intent separately.

This solves the cardinality problem, the staleness problem, and the lifecycle problem all at once. A 'revisit' isn't a separate entity you have to manually delete when done—it's literally the unfinished work in your filesystem. When you complete the task, it vanishes naturally.

The cost? You lose the temporal abstraction. You can't say "remind me about this in two weeks"—but that's a power-user feature solving a problem most developers don't have. The 80% case is: "finish what you started yesterday", and that's already encoded in your git history, your TODO markers, your test suite status.

Add one small thing: a session-start hook that surfaces incomplete tasks from the previous session. Not as a separate memory query, but as a natural continuation of the workflow restoration process. That's intent storage that actually fits how developers work.

### 2026-01-17T22:11:47.047Z - Conclusion
Intent storage (revisit/remind) should not be added as a separate memory type. Multi-agent deliberation revealed: (1) Knowledge is append-only and compounds in value; intent is consumable and decays—fundamentally different lifecycles. (2) The handover system already solves session continuity; enhancing handover structure with explicit intent sections is preferable to new storage. (3) SDD artifacts (tasks.md checkboxes, clarification markers) already encode intent implicitly. (4) Searchable tags on existing knowledge (@next-session, @blocked-on) provide intent signalling without new types. (5) The codebase itself encodes intent through unfinished work. (6) Separate intent storage creates graph pollution, temporal testing challenges, documentation drift, and lifecycle complexity. The real problem isn't 'remembering to revisit'—it's context loss between sessions, which handovers already address.
