---
type: breadcrumb
title: "Think: Memory Hook Enhancement Plan Review"
topic: Memory Hook Enhancement Plan Review
status: concluded
created: "2026-01-15T19:41:59.331Z"
updated: "2026-01-15T19:44:49.350Z"
tags:
  - think
  - concluded
scope: project
conclusion: "REFINED PLAN: (1) Phase 1 - Retrospective log reading in session-restore, include link suggestions from memory-commit output in retrospective context. (2) Phase 2 - PreCompact sync only (essential for data integrity), with clear error handling: log and continue, never block compaction. (3) Defer suggest-links hook entirely - surface suggestions in retrospective instead. (4) Defer archive/cleanup - prune already handles expiry. (5) Keep start-memory-index.ts focused - add think list display but NOT health checks there. (6) Add simple .last-commit-status file for memory-capture feedback. (7) Document error handling semantics for all hooks: log failures, never block critical operations."
promotedTo: decision-memory-hook-enhancement-plan-review
---

# Memory Hook Enhancement Plan Review

_Thinking document created 2026-01-15T19:41:59.331Z_

## Thoughts

### 2026-01-15T19:42:07.779Z - Thought
Phase 1 (Retrospective Integration) is HIGH VALUE. Reading the existing log directly avoids agent spawn overhead. The log already contains session summary, what worked/failed, and memory IDs captured. This is the most impactful change with lowest effort.

### 2026-01-15T19:42:20.141Z - Counter-argument
POTENTIAL OVERKILL: PostToolUse suggest-links hook. Running suggest-links after every memory write adds latency. Embeddings computation is expensive. Better as a manual command or periodic batch job rather than automatic hook. Risk of noise - too many suggestions irritates users.

### 2026-01-15T19:42:22.152Z - Counter-argument
POTENTIAL OVERKILL: retrospective-parser command. If we're just grepping the log in session-restore, a separate command adds unnecessary abstraction. Keep it inline unless parsing becomes complex.

### 2026-01-15T19:42:24.917Z - Thought
MISSING: No hook for memory-commit success/failure notification. When PreCompact spawns background memory-capture, there's no feedback on whether it succeeded. Should log result or create a status file that session-restore can check.

### 2026-01-15T19:42:37.058Z - Thought
MISSING: Think document expiry handling. Plan mentions archiving old thinking docs but doesn't address what happens to thinking docs that were never concluded. Should they auto-expire after N days? Should session-restore surface them as 'abandoned deliberations'?

### 2026-01-15T19:42:39.915Z - Alternative
ALTERNATIVE for suggest-links: Instead of PostToolUse hook, add suggest-links to memory-commit command itself. When committing memories, automatically check for link suggestions and include them in the commit output. User reviews during commit, not after every write.

### 2026-01-15T19:42:41.785Z - Thought
GOOD: PreCompact sync is essential. Currently memory-capture can spawn before index/graph are consistent. Running sync first ensures the spawned session sees accurate state. Low overhead, high value.

### 2026-01-15T19:42:55.950Z - Counter-argument
CONCERN: Four new hook files in Phase 2 is ambitious. Each needs tests, registration, error handling. Risk of scope creep. Consider implementing incrementally: start with sync (pre-compact) and health-check (session-start), defer suggest-links and archive to later iteration.

### 2026-01-15T19:42:58.836Z - Thought
PRIORITY REFINEMENT: (1) Retrospective log reading - immediate value, low effort. (2) PreCompact sync - data integrity, essential. (3) SessionStart health+think list - user awareness. (4) Archive/cleanup - defer, already have prune. (5) suggest-links - defer, move to memory-commit instead of hook.

### 2026-01-15T19:43:03.882Z - Thought
SIMPLIFICATION: Phase 3 'enhance existing hooks' can be merged into Phase 2. Don't create separate memory-health-check.ts - add health check to existing start-memory-index.ts. One file, one responsibility.

### 2026-01-15T19:44:01.058Z - Thought (model:haiku [68c3aa37-f03f-4ae2-9db3-ccf0865fb996])
The scope creep concern is absolutely valid—four hook files is ambitious, but the priority refinement nails the right sequencing. However, I'd push back slightly on deferring suggest-links entirely. Instead of moving it to memory-commit (which adds latency to a user-facing command), consider this: make suggest-links opt-in via a config flag that defaults to disabled. Phase 2 implements the hook infrastructure, but users don't pay the embedding cost unless they explicitly enable it. This gives you the capability without forcing the overhead.

On memory-commit success/failure: don't overthink this. A simple approach—write a `.claude/memory/.last-commit-status` file with timestamp and exit code—lets session-restore check it instantly without spawning anything. If PreCompact fails, the next session sees it immediately and can surface it as "Memory capture failed in last session—last successful capture was X hours ago." This is low-friction feedback without adding complexity.

Think document expiry is real but honestly doesn't belong in Phase 2. You've already got prune logic. Instead, add a single passive check in session-restore: if there are thinking docs older than 30 days without a conclusion, log them as "abandoned deliberations" and suggest the user review/conclude them. This surfaces the problem without automating away potentially valuable work.

Merging Phase 3 into Phase 2 is correct, but be precise about it: don't add health checks to start-memory-index.ts. Create a new `ensure-memory-health.ts` that's specifically a utility function (not a hook), then call it from session-start hook. Keeps responsibilities clean without spawning extra files. The hook stays thin (call utility, report status), the logic lives in a testable function.

The real insight here: Phase 2 is about *reliability*, not features. Sync before compaction, status notification, health awareness—these are all about making the system observable and resilient. Suggest-links and archive are nice-to-haves that muddy that goal. Defer them, implement Phase 2 as the solid foundation it should be.

### 2026-01-15T19:44:36.772Z - Counter-argument (model:claude-sonnet-4-5-20250929 [8ff50dfc-7484-47f3-b786-31883650dbb0])
The opt-in config flag sounds elegant but creates a configuration landmine. Users won't discover the feature exists because it's hidden behind a default-off flag. And who's maintaining that flag's documentation? It's already unclear where memory config lives (is it .claude/memory/config.json? Environment variables? Per-project?). Adding another toggle increases surface area without solving the core problem: embeddings computation is slow regardless of when it runs.

The real issue is that suggest-links shouldn't be automatic at all. Memory creation is already cognitively expensive—you're mid-session, capturing a learning, and now you're interrupted with "here are 7 possible links, review them". That's context-switching overhead dressed up as helpfulness. The retrospective log already contains memory IDs—why not surface link suggestions there instead? When reviewing the retrospective, you're already in reflection mode. Suggesting links alongside "what worked/what failed" is contextually appropriate.

Also suspicious: merging Phase 3 into Phase 2. Yes, fewer files sounds cleaner, but `start-memory-index.ts` is already doing embeddings initialization. Shoving health checks in there violates single responsibility. Health checking (is graph corrupted? Are embeddings stale?) is orthogonal to index building. If index startup fails, you can't run health checks anyway. Keep them separate or you've created a God file that does "memory system initialization plus validation plus diagnostics".

And nobody's addressing the elephant: what happens when a hook fails? If PreCompact sync errors out, does compaction abort? Does it log and continue? The plan doesn't specify error handling semantics for any of these hooks. That's concerning because hooks run in system context—users can't easily debug them. One bad hook could brick the entire memory system silently.

### 2026-01-15T19:44:49.349Z - Conclusion
REFINED PLAN: (1) Phase 1 - Retrospective log reading in session-restore, include link suggestions from memory-commit output in retrospective context. (2) Phase 2 - PreCompact sync only (essential for data integrity), with clear error handling: log and continue, never block compaction. (3) Defer suggest-links hook entirely - surface suggestions in retrospective instead. (4) Defer archive/cleanup - prune already handles expiry. (5) Keep start-memory-index.ts focused - add think list display but NOT health checks there. (6) Add simple .last-commit-status file for memory-capture feedback. (7) Document error handling semantics for all hooks: log failures, never block critical operations.
