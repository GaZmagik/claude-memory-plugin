/**
 * T050: Gitignore automation for local scope
 *
 * Automatically adds .claude/memory/local/ to .gitignore
 * to keep local memories private.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { findGitRoot } from './git-utils.js';
import { createLogger } from '../core/logger.js';

const log = createLogger('gitignore');

/** Pattern to add to .gitignore for local memories */
export const MEMORY_LOCAL_PATTERN = '.claude/memory/local/';

/** Comment to add before the pattern */
const MEMORY_LOCAL_COMMENT = '# Claude Code local memories (personal, not shared)';

/**
 * Result of gitignore operation
 */
export interface GitignoreResult {
  /** Whether .gitignore was created */
  created: boolean;
  /** Whether .gitignore was modified */
  modified: boolean;
  /** Whether pattern was already present */
  alreadyPresent: boolean;
  /** Whether operation was skipped */
  skipped: boolean;
  /** Reason for skipping */
  reason?: string;
}

/**
 * Ensure the local scope directory is gitignored
 *
 * @param projectRoot - Project root directory (or cwd)
 * @returns Result of the operation
 */
export function ensureLocalScopeGitignored(projectRoot: string): GitignoreResult {
  // Find git root
  const gitRoot = findGitRoot(projectRoot);
  if (!gitRoot) {
    return {
      created: false,
      modified: false,
      alreadyPresent: false,
      skipped: true,
      reason: 'Not a git repository',
    };
  }

  const gitignorePath = path.join(gitRoot, '.gitignore');

  // Check if already present
  if (isPathGitignored(gitRoot, MEMORY_LOCAL_PATTERN)) {
    return {
      created: false,
      modified: false,
      alreadyPresent: true,
      skipped: false,
    };
  }

  // Create or modify .gitignore
  const created = createGitignoreIfMissing(gitRoot);
  addToGitignore(gitRoot, MEMORY_LOCAL_PATTERN, MEMORY_LOCAL_COMMENT);

  log.info('Added local memory path to .gitignore', { path: gitignorePath });

  return {
    created,
    modified: !created,
    alreadyPresent: false,
    skipped: false,
  };
}

/**
 * Check if a pattern is in the .gitignore file
 */
export function isPathGitignored(gitRoot: string, pattern: string): boolean {
  const gitignorePath = path.join(gitRoot, '.gitignore');

  if (!fs.existsSync(gitignorePath)) {
    return false;
  }

  try {
    const content = fs.readFileSync(gitignorePath, 'utf-8');
    const lines = content.split(/\r?\n/);

    // Check for exact match (with optional whitespace)
    const normalizedPattern = pattern.trim();
    return lines.some(line => line.trim() === normalizedPattern);
  } catch {
    return false;
  }
}

/**
 * Add a pattern to .gitignore
 *
 * @param gitRoot - Git repository root
 * @param pattern - Pattern to add
 * @param comment - Optional comment to add before the pattern
 */
export function addToGitignore(
  gitRoot: string,
  pattern: string,
  comment?: string
): void {
  const gitignorePath = path.join(gitRoot, '.gitignore');

  let content = '';
  if (fs.existsSync(gitignorePath)) {
    content = fs.readFileSync(gitignorePath, 'utf-8');
  }

  // Ensure content ends with newline
  if (content && !content.endsWith('\n')) {
    content += '\n';
  }

  // Add blank line before comment/pattern if content exists
  if (content && content.trim().length > 0 && comment) {
    content += '\n';
  }

  // Add comment if provided (ensure it starts with #)
  if (comment) {
    const commentLine = comment.startsWith('#') ? comment : `# ${comment}`;
    content += commentLine + '\n';
  }

  // Add pattern
  content += pattern + '\n';

  fs.writeFileSync(gitignorePath, content);
  log.debug('Added to .gitignore', { pattern });
}

/**
 * Create .gitignore if it doesn't exist
 *
 * @param gitRoot - Git repository root
 * @returns true if created, false if already exists
 */
export function createGitignoreIfMissing(gitRoot: string): boolean {
  const gitignorePath = path.join(gitRoot, '.gitignore');

  if (fs.existsSync(gitignorePath)) {
    return false;
  }

  const initialContent = '# Generated by Claude Code\n\n';
  fs.writeFileSync(gitignorePath, initialContent);
  log.debug('Created .gitignore', { path: gitignorePath });

  return true;
}

/**
 * Remove a pattern from .gitignore
 *
 * @param gitRoot - Git repository root
 * @param pattern - Pattern to remove
 * @returns true if removed, false if not found
 */
export function removeFromGitignore(gitRoot: string, pattern: string): boolean {
  const gitignorePath = path.join(gitRoot, '.gitignore');

  if (!fs.existsSync(gitignorePath)) {
    return false;
  }

  const content = fs.readFileSync(gitignorePath, 'utf-8');
  const lines = content.split(/\r?\n/);
  const normalizedPattern = pattern.trim();

  const filteredLines = lines.filter(line => line.trim() !== normalizedPattern);

  if (filteredLines.length === lines.length) {
    return false; // Pattern not found
  }

  fs.writeFileSync(gitignorePath, filteredLines.join('\n'));
  log.debug('Removed from .gitignore', { pattern });

  return true;
}

/**
 * Check all local memory patterns are gitignored
 */
export function validateGitignorePatterns(gitRoot: string): {
  valid: boolean;
  missing: string[];
} {
  const requiredPatterns = [MEMORY_LOCAL_PATTERN];
  const missing: string[] = [];

  for (const pattern of requiredPatterns) {
    if (!isPathGitignored(gitRoot, pattern)) {
      missing.push(pattern);
    }
  }

  return {
    valid: missing.length === 0,
    missing,
  };
}
