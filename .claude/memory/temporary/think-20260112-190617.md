---
type: breadcrumb
title: "Think: TDD Plugin Architecture: TypeScript-for-all vs Native Languages"
topic: "TDD Plugin Architecture: TypeScript-for-all vs Native Languages"
status: active
created: "2026-01-12T19:06:17.085Z"
updated: "2026-01-12T19:21:05.680Z"
tags:
  - think
  - active
scope: project
---

# TDD Plugin Architecture: TypeScript-for-all vs Native Languages

_Thinking document created 2026-01-12T19:06:17.085Z_

## Thoughts

### 2026-01-12T19:10:44.339Z - Thought
DECISION CONTEXT: Should TDD enforcement hooks be written in TypeScript (via Bun) for all languages, or natively per-language (Python hook in Python, Rust hook in Rust, etc.)? Current state: Both tdd-python.ts and tdd-typescript.ts are already in TypeScript. Hooks perform: file existence checks, pattern matching, .tddignore parsing, subprocess calls to test runners (pytest, vitest), optional Ollama LLM quality checks.

### 2026-01-12T19:18:39.537Z - Thought (Architect)
ARCHITECT VIEW: TypeScript-for-all creates a clean system boundary - hooks are infrastructure, not application code. The subprocess interface to test runners (pytest, cargo test, vitest) is the natural API contract. Native language hooks would couple infrastructure to application-language concerns, violating separation of concerns. One language = one build system, one test suite, one deployment model.

### 2026-01-12T19:19:00.129Z - Thought (TypeScript Expert)
TYPESCRIPT EXPERT: Bun starts in ~10ms vs Python's ~150ms - critical for pre-tool-use hooks that run on every Write/Edit. TypeScript's type system catches hook bugs at compile time. Shared utilities (subprocess.ts, error-handler.ts, tddignore parsing) work across all language hooks without reimplementation. vitest can test all hooks in one suite with consistent mocking patterns.

### 2026-01-12T19:19:01.390Z - Counter-argument (Python Expert)
PYTHON EXPERT: Native Python hook could import pytest directly, access collection hooks, parse Python AST for test quality analysis without subprocess. Could leverage Python's rich introspection to detect mocking patterns, fixture usage, assertion quality. TypeScript hook treats Python as black box - loses semantic understanding.

### 2026-01-12T19:19:02.510Z - Thought (Rust Expert)
RUST EXPERT: Rust's cargo test has excellent machine-readable output (--format json). A TypeScript hook can parse this just as well as a Rust hook could. The real value of Rust (memory safety, zero-cost abstractions) doesn't apply to hooks - they're short-lived processes doing I/O. TypeScript is fine here.

### 2026-01-12T19:19:17.002Z - Thought (Test Quality Expert)
TEST QUALITY EXPERT: Unified TypeScript hooks mean one testing strategy. Can mock subprocess.spawn() consistently, test .tddignore parsing once and reuse. Native hooks would require: pytest for Python hook tests, vitest for TS hook tests, cargo test for Rust hooks - triple the CI complexity, triple the test patterns to maintain.

### 2026-01-12T19:19:18.103Z - Thought (Performance Expert)
PERFORMANCE EXPERT: Hook startup latency matters - runs on every Write/Edit. Bun: ~10ms cold start. Python: ~100-200ms with imports. Node: ~50ms. For a hook that might run 50+ times per session, TypeScript/Bun saves 5-10 seconds cumulative. Subprocess overhead to pytest (~200ms) is unavoidable either way.

### 2026-01-12T19:19:19.618Z - Counter-argument (Devils Advocate)
DEVILS ADVOCATE: But what about Go hooks? Go compiles to native binary with ~5ms startup. A Go hook could be faster than Bun AND have native access to go/ast for Go code analysis. Are we prematurely optimising for TypeScript when the best tool might vary per language?

### 2026-01-12T19:19:32.878Z - Thought (Pragmatist)
PRAGMATIST: The hooks already exist in TypeScript and work. Rewriting in native languages is effort with no user-visible benefit. The 90% case (file exists? pattern match? run subprocess?) doesn't need native capabilities. Ship what works, iterate if needed.

### 2026-01-12T19:19:34.129Z - Thought (Security Auditor)
SECURITY AUDITOR: Fewer languages = smaller attack surface. One runtime (Bun) to audit, one set of dependencies to track. Native hooks mean trusting pip packages, cargo crates, go modules for each language. TypeScript consolidation reduces supply chain risk.

### 2026-01-12T19:19:36.390Z - Thought (Simplifier)
SIMPLIFIER: One language. One test runner. One package manager. One way to debug. The complexity cost of N languages for N hooks grows quadratically with contributor confusion. TypeScript-for-all is the KISS principle applied to infrastructure.

### 2026-01-12T19:20:00.665Z - Counter-argument (Risk Assessor)
RISK ASSESSOR: TypeScript-for-all creates single point of failure. If Bun has a bug, ALL hooks break. Native hooks isolate failures - Python hook bug doesn't affect Rust hook. Diversification reduces blast radius.

### 2026-01-12T19:20:02.161Z - Counter-argument (Code Quality Expert)
CODE QUALITY EXPERT: Native hooks would be more idiomatic. Python developers understand pytest fixtures better than TypeScript developers spawning pytest. Rust developers can leverage cargo's built-in test attributes. Expertise alignment matters for maintainability.

### 2026-01-12T19:20:03.753Z - Counter-argument (Node.js Expert)
NODE.JS EXPERT: Why Bun specifically? Node.js has larger ecosystem, better Windows support, more stable API. Locking to Bun creates vendor risk. If choosing TypeScript runtime, Node might be safer long-term choice despite slower startup.

### 2026-01-12T19:20:14.198Z - Counter-argument (Documentation Expert)
DOCUMENTATION EXPERT: Contributors will need to understand TypeScript to modify any hook, regardless of their primary language. This raises barrier to contribution for Python-only or Rust-only developers who want to improve their language's TDD enforcement.

### 2026-01-12T19:20:15.969Z - Counter-argument (User Advocate)
USER ADVOCATE: From user perspective, they don't care what language hooks are in. They care that TDD is enforced correctly for THEIR language. If native hooks could detect more issues (via AST analysis), that's user value. Implementation language is invisible to users.

### 2026-01-12T19:20:30.326Z - Alternative (Architect)
HYBRID OPTION 1: TypeScript orchestration layer + native analysis plugins. Core hook logic (file checks, .tddignore, blocking) in TypeScript. Language-specific deep analysis (AST, coverage parsing) as optional native plugins called via subprocess when available.

### 2026-01-12T19:20:31.621Z - Alternative (Pragmatist)
HYBRID OPTION 2: Tiered approach. Basic TDD enforcement (file exists?) in TypeScript for all languages. Advanced enforcement (test quality analysis, coverage thresholds) only for languages where TypeScript can adequately parse output (Python pytest JSON, Rust cargo JSON).

### 2026-01-12T19:20:33.395Z - Alternative (Pragmatist)
HYBRID OPTION 3: Start TypeScript-for-all, design for extensibility. Define plugin interface that COULD support native analysers later. YAGNI now, but don't close the door. Ship TypeScript hooks, measure gaps, add native plugins only where proven necessary.

### 2026-01-12T19:20:46.113Z - Alternative (Architect)
HYBRID OPTION 4: Use WASM for language-specific analysis. Compile Python AST parser, Rust analyser to WASM. Call from TypeScript. Single runtime (Bun), but with native-quality analysis. Complexity cost is high but theoretically possible.

### 2026-01-12T19:20:47.870Z - Alternative (Simplifier)
ALTERNATIVE: Use Ollama/LLM for ALL language analysis. Instead of native AST parsing, send code to LLM for quality assessment. Language-agnostic, already implemented for fake test detection. Could extend to coverage analysis, test completeness. Graceful degradation if Ollama unavailable.

### 2026-01-12T19:20:49.297Z - Thought (Product Manager)
PRODUCT MANAGER: What's the MVP? TypeScript hooks exist and work. User need is TDD enforcement, not perfect language-native analysis. Ship TypeScript-for-all, collect feedback, iterate. Premature optimisation for native hooks is scope creep.

### 2026-01-12T19:21:04.549Z - Thought (Mentor)
MENTOR: Consider maintenance burden over 3 years. Who will maintain these hooks? If answer is 'primarily one person comfortable with TypeScript', then TypeScript-for-all wins. If answer is 'language community experts', native might be better. Know your contributor base.

### 2026-01-12T19:21:05.680Z - Thought (Product Manager)
LANGUAGE COVERAGE: Which languages to support? Priority order based on Claude Code usage: 1) TypeScript/JavaScript (done), 2) Python (done), 3) Rust (popular in systems), 4) Go (popular backend), 5) Ruby (Rails). Java/C# have complex build systems - defer unless demanded.
